<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Type Manipulation</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; }
    h1, h2, h3 { color: #3178c6; }
    pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
    code { font-family: Consolas, monospace; }
    .back-link { margin-top: 20px; display: inline-block; }
  </style>
</head>
<body>
  <h1>Advanced Type Manipulation</h1>

  <h2>1. Generics & Constraints</h2>
  <pre><code>
// Basic generic function
function identity<T>(arg: T): T {
  return arg;
}

const num = identity(5);         // Type: number
const str = identity("hello");   // Type: string

// Generic interface
interface Box<T> {
  contents: T;
}

const numberBox: Box<number> = { contents: 42 };
const stringBox: Box<string> = { contents: "hello" };

// Generic constraints
interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(arg: T): T {
  console.log(arg.length);  // Safe because of constraint
  return arg;
}

// Works with strings, arrays, and any type with a length property
logLength("hello");     // Output: 5
logLength([1, 2, 3]);   // Output: 3

// Complex constraint example
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

// Using Record for flexible object types
function processRecord<T extends Record<string, unknown>>(data: T): T {
  // Process the data...
  return data;
}
  </code></pre>

  <h2>2. Mapped & Conditional Types</h2>
  <pre><code>
// Mapped Types
interface User {
  id: number;
  name: string;
  email: string;
}

// Make all properties optional
type PartialUser = {
  [K in keyof User]?: User[K];
};

// Make all properties readonly
type ReadonlyUser = {
  readonly [K in keyof User]: User[K];
};

// Create a type with all properties nullable
type NullableUser = {
  [K in keyof User]: User[K] | null;
};

// Conditional Types
type IsString<T> = T extends string ? true : false;

type CheckString = IsString<"hello">;   // Type: true
type CheckNumber = IsString<42>;        // Type: false

// Extract vs. Exclude utility types
type Numbers = 1 | 2 | 3 | 4 | 5;
type Strings = "one" | "two" | "three";
type Union = Numbers | Strings;

type OnlyStrings = Extract<Union, string>;  // "one" | "two" | "three"
type OnlyNumbers = Extract<Union, number>;  // 1 | 2 | 3 | 4 | 5
type NoStrings = Exclude<Union, string>;    // 1 | 2 | 3 | 4 | 5

// Advanced example: creating a type that picks only methods from an interface
type Methods<T> = {
  [K in keyof T as T[K] extends Function ? K : never]: T[K]
};

interface Person {
  name: string;
  age: number;
  greet(): void;
  walk(): void;
}

type PersonMethods = Methods<Person>;  // { greet: () => void; walk: () => void; }
  </code></pre>

  <h2>3. Template Literal Types</h2>
  <pre><code>
// Basic template literal type
type Greeting = `Hello, ${string}!`;
let greeting: Greeting = "Hello, TypeScript!";  // Valid
// let invalid: Greeting = "Hi there";          // Error

// Combining with union types
type Alignment = "left" | "right" | "center";
type Variant = "primary" | "secondary";
type ButtonClass = `btn-${Alignment}-${Variant}`;

// Valid values:
// "btn-left-primary", "btn-left-secondary",
// "btn-right-primary", "btn-right-secondary",
// "btn-center-primary", "btn-center-secondary"

// CSS properties example
type CSSValue = number | string;
type CSSProperty<T extends string> = `${T}` | `${T}-top` | `${T}-right` | `${T}-bottom` | `${T}-left`;
type MarginProperty = CSSProperty<"margin">;
// "margin" | "margin-top" | "margin-right" | "margin-bottom" | "margin-left"

// Event handler naming
type EventNames = "click" | "change" | "mouseover";
type HandlerNames = `on${Capitalize<EventNames>}`;
// "onClick" | "onChange" | "onMouseover"

// URL path builder
type Path = `/api/${string}`;
const validPath: Path = "/api/users";  // Valid
// const invalidPath: Path = "/invalid";  // Error
  </code></pre>

  <h2>4. Key Querying Utilities</h2>
  <pre><code>
// keyof operator
interface Product {
  id: number;
  name: string;
  price: number;
  category: string;
}

type ProductKeys = keyof Product;  // "id" | "name" | "price" | "category"

// typeof operator with keyof
const config = {
  server: "localhost",
  port: 3000,
  timeout: 5000
};

type ConfigKeys = keyof typeof config;  // "server" | "port" | "timeout"

// Indexed Access Types
type PriceType = Product["price"];  // number
type NameOrCategory = Product["name" | "category"];  // string

// Get all value types of an object
type ProductValues = Product[keyof Product];  // number | string

// Dynamic property access with keyof and generics
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const product: Product = { id: 1, name: "Laptop", price: 999, category: "Electronics" };
const productName = getProperty(product, "name");  // Type: string
const productPrice = getProperty(product, "price");  // Type: number
// const error = getProperty(product, "discount");  // Error: 'discount' is not a key of Product
  </code></pre>

  <h2>5. Discriminated Unions & Exhaustive Pattern Matching</h2>
  <pre><code>
// Discriminated union with 'kind' property
type Shape = 
  | { kind: "circle"; radius: number }
  | { kind: "square"; sideLength: number }
  | { kind: "rectangle"; width: number; height: number };

// Type-safe processing with exhaustive checks
function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    case "rectangle":
      return shape.width * shape.height;
    default:
      // Exhaustiveness check
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}

// API response handling example
type ApiResponse = 
  | { status: "success"; data: unknown }
  | { status: "error"; error: string }
  | { status: "loading" };

function handleResponse(response: ApiResponse) {
  switch (response.status) {
    case "success":
      console.log("Data:", response.data);
      break;
    case "error":
      console.error("Error:", response.error);
      break;
    case "loading":
      console.log("Loading...");
      break;
    default:
      // If we add a new status type but forget to handle it,
      // TypeScript will error on this line
      const _exhaustiveCheck: never = response;
      return _exhaustiveCheck;
  }
}

// State machine with discriminated unions
type State = 
  | { type: "idle" }
  | { type: "loading" }
  | { type: "success"; data: string }
  | { type: "error"; error: Error };

// Type-safe state transitions
function reducer(state: State, action: { type: string; payload?: any }): State {
  switch (action.type) {
    case "FETCH_START":
      return { type: "loading" };
    case "FETCH_SUCCESS":
      return { type: "success", data: action.payload };
    case "FETCH_ERROR":
      return { type: "error", error: action.payload };
    default:
      return state;
  }
}
  </code></pre>

  <a href="/" class="back-link">‚Üê Back to Index</a>
</body>
</html>
